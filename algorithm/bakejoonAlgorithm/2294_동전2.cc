/*
  동전1풀고 만만하게 생각했으나 난 아직 멀었다
  역시 dp 문제다. d[i]가 동전의 값이 아닌 동전의 최소 '개수'라는 점에 유의해야 한다.
  d[i]=i원을 만들기 위해 사용한 동전의 최소 개수~
*/
#include <cstdio>
int a[101];
int d[10001];
int main() {
    int n,m; 
    scanf("%d %d",&n,&m); //n,k 입력
    for (int i=1; i<=n; i++) {
        scanf("%d",&a[i]);
    }
    for (int i=0; i<=m; i++) {
        d[i] = -1; //d[]배열을 모두 -1로 초기화
    }
    d[0] = 0;
    for (int i=1; i<=n; i++) { //동전 종류를 하나씩 돌린다
        for (int j=0; j<=m; j++) { //k원이 될때까지
        //k원에서 1동전 뺀게 음수가 아니고, k원에서 1동전만큼 뺀 값이 아직 안들어있다면
            if (j-a[i] >= 0 && d[j-a[i]] != -1) { 
            	//j원일때 값이 아직 없거나,  j원-1동전일 때의 d[]배열이(횟수가) j원일때의 횟수보다 작으면
                if (d[j] == -1 || d[j] > d[j-a[i]]+1) {
                    d[j] = d[j-a[i]] + 1; //이 값을 j원일때로 넣는다.
                }
            } //즉, 값을 하나씩 비교하면서 사용한 동전의 최소 개수를 넣는다. 
        }
    }
    printf("%d\n",d[m]); //k원일때 사용한 동전의 최소 개수를 출력한다
    return 0;
}
