/*
  다이나믹이다..
  문제에서 합을 이루고 있는 순의 순서만 다른 것은 같은 것으로 친다고 했으므로 중복을 없애려면
  모든 수가 오름차순이면 된다.
  1이 먼저 등장, 2 등장, 3이 등장이므로 1을 이용해서 모두 만들고, 
  그 결과를 이용해서 2를 만들어보고, 
  그 결과를 이용해서 3으로만 만들어본다.
  
  점화식 d[i]=i를 1,2,3의 합으로 나타내는 방법의 수
  1만 있다고 하고 다 채우고 d[i]=d[i-1], 이를 이용해서
  2만 있다고 하고 채워보고 d[i]=[i-2] ... 3만 사용한다면 d[i]=d[i-3]...
*/
#include <iostream>
using namespace std;
int d[10001];
const int limit=10001;
int main() {
	d[0]=1;
	
	for(int j=1; j<=3; j++){ //1,2,3만 사용하는 경우...
		for(int i=1; i<=limit; i++){
			if(i-j>=0){
				d[i]+=d[i-j];
			}	
		}
	}
	
	int t;
	cin>>t;
	while(t--){
		int n;
		scanf("%d",&n);
		printf("%d\n",d[n]);
	}
}
