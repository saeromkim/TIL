# BFS - 덱 사용하기
- 가중치가 0또는 1일때 사용 가능
## 숨바꼭질3
- 거리가 0인 정점은 그냥 같은 정점이라고 생각
- 0초걸리는 큐는 따로 저장. 
- 가중치가 0과 1인 경우 최단 거리 
- q를 두개 만든다.(next_queue를 만듬)
- 덱을 사용하는 dfs는 0과 1이 나오는 경우
- 이 경우는 드물어서 잘 안나온다.
- 가중치가 0이 나오면 이상이상..그래서 잘 안나온다 .
## 알고스팟
- 벽의 개수를 최소로 해야한다.
- 벽을 부수는 횟수의 최솟값을 구하는 문제
- 생각 잘 해보기 .
## 벽 부수고 이동하기
- 벽은 한번 부수고 지나갈 수 있다. (중요)
- 방문하는 칸의 개수 최소(미로탐색, 알고스팟 0과 1이 나오는 문제)
- 벽을 한번도 부순적이 없을 때 벽을 부수면 된다.
- 앞에서 어떤 정점에서 할 수 있는게 달라졌다.
- 이 문제 역시 벽을 부순 횟수가 0번이다.
- 이 문제는 정점을 칸의 좌표와 벽을 부순 횟수
-  (r,c,k)(...)
- bfs문제 다 비슷비슷하다
- 정점의 정의를 어디에 둘것인가
- 이 뒤에 있는 문제는 읽어보고 목요일날 해봅시다. (숙제)
- 탈출, 탈옥, 열쇠
## 부분집합의 합
## 종이 조각(.zzzz숨참기)껌이나 사탕 준비하기 
- 각각의 칸이 가로, 세로인지 정한다.
- 그 다음 문자의 합을 구하면 된다. 
- 전체 시간 목잡도는 2^m
- 제곱이 나오니까 
- 총 복잡도
## 구슬탈출2 집중하자!
- 4가지 방법을 10번사용할 수 있으면 4^10가지
- 같은 방향 두번, 반대 방향으로 이동하는 것은 의미가 없다잉 
- 이 경우를 줄이면 경우의 수도 줄어든다. 
- 벽이 올때까지 쭉~이동하면 됨 
- 하나의 구슬이 이동하다가 다른 구슬이 있다면
- 1. 동시에 두개를 이동시키거나 2.두개를 번갈아가면서 이동시키던가
- 이 문제의 가장 큰 교훈이...
- 경우의 수가 줄어드니까 브루트포스로 풀자 이거임~
- 10번이라는 조건때문에 풀 수 있었다. (난이도를 낮추는 용)
- 만약 이 조건이 없다면 bfs로 풀어야하는 문제다(나중에 해볼거얌)
## 2048(easy)
- 5번 이동 횟수가 가장 중요 
- 모든 방향을 다 해보면 풀 수있어용~~
- 경우의 수만 확인해보면 브루트 포스로 풀 수 있다


- 브루트포스-문제 는 직접 풀어보세요 
- 모르겠으면 이렇게 푸는구나 참고요으로 많이 보세요

# 분할 정복
- 문제를 절반으로 쪼개는 것
- 다이나믹은 문제를 작은 문제로 쪼개는 것
- 예시로 큰 수 곱셈
- 앞에서 본 재귀나 브루트 포스랑 비슷하당
# 이분 탐색
- 매우 중요허다
- 정렬되어있는 리스트에서 어떤 값을 빠르게 찾는 알고리즘
- 정렬되어있지 않으면 o(n)
- 정렬되어있으면 o(logn) 반으로 반으로 쪼개니까
- 지금은 뭔지만. 다음주에는 문제 풀이
- left,right변수 두개로 구현한당~
- right를 포함할지 말지도 다르게 할 수 있다. 대부분 구현할때 end는 포함안하니까 ...뭐 근데 [l,r]해도됨
- 처음 배울땐 정말 중요한데 그렇게 많이 쓰진 않는다.
- 값이 고정되지 않는 경우가 많기 때문에..대신 원리가 많이 쓰인다
- 업앤다운 게임 같은데 사용된당 다음주에 이분탐색 이용한 문제 풀거당
# 상한과 하한
- lower $ upper_bound
- upper - lower 하면 그 수가 몇개 있는지를 알 수 있다. 
- 없는 수는 위치가 0임 
- 정렬되어있을 때만 됨

- binary_search 라는 함수가c++에 내장되어 있는데, true,false값 반환. 값의 존재만 알수있덩
- lower&upper_bound는 위치까지 알 수 있다
# 머지 소트
- 엄~청 중요허당
- o(NlonN)정렬만 알면된다. n^2짜린 몰라도됨
- 머지, 퀵, 힙이 이에 해당된다.
- 문제 풀때는 정렬을 구현할 일은 없다 라이브러리 쓰면 돼서.
- 절반으로 나누고 양쪽을 정렬한다(재귀) 다시 합치는 것(merge())이 머지 소트다
- 전제 조건은 양쪽 배열이 다 정렬이 되어있다는 것이다(중요)
- b[]라는 배열을 새로 만들어서 둘이 합쳐준다. 
- stable_sorting 이기도 함(버블 소팅도), 다른 알고리즘은 몰러  
# 퀵 소트(??조금 이해안간다 이거!)
- 피벗이라는 것을 정하고 왼쪽 오른쪽 으로 작고 큰 것을 정해서 보낸다. 
- 피벗은 기준이다. 자기맘대로임
- 피벗을 정하는게 상당히 중요허다
- 평균적으로 nlogn이나, 최악의 경우 n^2이 걸릴 수도
- depth가 오래걸리면 다른 정렬알고리즘을 쓸 수 있다. (intro sort) 성능이 매우 빠름
# 퀵 셀렉트
- 한쪽만 호출해서 정렬함
- O(N)
# 문제 풀기
## 하노이 탑
- 원판이 1개일때 1번, 2개일때 3번로 일반화 할수 잇다.
- x,y는 123중 하나이므로 6-x-y라고 하면 셋중에 하나라고 표현할 수 있다
- 일반항을 구하는 건 필요없긴 하지만 하노이탑은 일반항이 있으니까 걍 한번 구해볼게,,

# 트리1
- 사이클이 없는 그래프당
- 정점이 v개, 간선이 v-1
- 원래는 루트가 없는데, 루트를 정할 수 있다!
- 루트는 내 맘대로 정한다. 4번이 루트일수도 
- 루트 부터 아래로 방향을 정할 수 있다. 
- 부모가 없는게 루트, 자식이 없는 마지막에 있는 게 단말정점(리프 노드)
- 깊이 : 루트에서부터 거리 
- 2의 조상: 2와 1 (자기 자신을 포함함에 유의)
- 자손: 아래꺼 (자기자신 포함)
- 이진트리 : 자식이 최대 2개있는 트리
## 트리의 표현
#### 저장방식 
 1. 트리의 부모만 저장하는 방식(1차원 배열 하나 사용)
  - 이때1은 0 (예외처리)
  - 위로만 탐색할 때 사용
  - union find라는 자료구조 사용할 때
 2. 이진 트리의 경우 배열로 저장
  - 힙, 세그먼트 트리 사용할 때
  - 부모의 노드가 x인 경우 2x, 2x+1 짝수, 홀수로 나타냄
  - 0번부터 하면 헷갈림~1번부터 써라.
  - 브루트포스 같은거 풀때도 0번부터 1번부터 하는거 자기 맘대로 편한대로 하세요
# 다시 분할 정복 문제들
## 트리의 순회
- dfs,bfs사용 가능
- dfs는 세가지로 나눈다. 프리오더 인오더 포스트오더(왼오노드)
- 이 수업의 목표에서는 순서 중요하지 않지만 대충 알아놩 (순식간에 108p)
- 포스트오더가 제일(거의 대부분) 중요하다. 자식 먼저 처리하고 현재 값을 이용하는 경우가 많기 때문
- 인오더는 잘 안씀
- 그래프의 dfs처럼 방문했다고 체크하고 탐색하는 경우 프리오더 많이 씀
#### 트리 순회 (트리1.ppt)
- 인오더, 포스트오더 순서를 가지고 프리오더 만들기 
- 포스트오더의 가장 마지막은 루트이다
- 인오더는 루트를 기준으로 왼쪽 오른쪽 나뉜다.
- 프리오더 인오더가 있어도 프리오더의 첫번째가 루트라는 성질을 이용해서 포스트오더를 구할 수 있다.
- 하지만 프리오더, 포스트오더를 알고 있을 때 인오더를 구하는 것은 불가능
- 다이나믹으로 푸세요
#### z
#### 사분면
- 두 문제는 나누는 대로 풀면 됨
#### 버블 소트
- 앞에서부터 인접한 두개만 정렬
- 버블 소트는 한번 순회가 n이므로 총 O(n^2)걸림
- 이 문제는 swap이 총 몇 번 일어났는지?
- 버블 소트 구현 후 교환 일어날 때마다 cnt++
- 그러나 시간이 너무 오래걸리므로 불가능하다
- 버블소트 이용하지 않고 교환 횟수 알아내야 함
- 1. 버블 소트는 한번 순회할때마다 맨 뒤에 있는 수는 항상 그 자리가 맞다
- 2. 뒤에있는 수가 앞으로 오는 경우는 1번이 최대다. 앞에서부터 단계적으로 비교하기 때문
-    앞에있는 수가 뒤로 가는 건 2번이상 가능
- 3. 앞에 큰수, 뒤에 작은수가 있으면 아무리 두수가 멀리 떨어져있어도 두 수가 위치를 바꾸는 단계가 반드시 온다.
- 이 문제에서는 3번째 성질 이용
- 앞에 있으면서 큰 수가 몇개 나오는지 찾으면 됨..! 1 5 7 2 3
- 머지 소트로 nlogn만에 풀 수 있다
- (여기 설명 약간 헷갈린다 다시 봐야겠따.)

- 슬라이드 중 문제, 2.5 등의 제목은 설명안하고 자습용
# 트리1
## 트리의 지름
- 사이클이 없다 : 임의의 두 정점 u,v 사이의 경로가 반드시 1개여야 한다.-->트리 문제다. 그래프가 아니라(중요)
- 이를 최단거리 찾을 때 사용한다 
- 최단거리를 트리는 dfs,bfs로 찾기만 하면 됨. 왜냐하면 하나니까 경로가
- 트리에 존재하는 모든 경로 중 가장 긴 것을 트리의 지름이라고 한다.
- 트리의 지름 구하는 문제는 트리의 지름 구하는 문제 하나 밖에 없다










