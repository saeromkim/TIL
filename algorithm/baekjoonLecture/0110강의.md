경우의 수를 나눈 나머지를 구하라고 하는 이유는 너무 큰 값이 나오기 때문
연산을 할 때마다 나머지 연산을 수행해야 한다.
예시: 2*n타일링 문제 

## 최대공약수
- 시간복잡도 O(logN)
- 쓸 데가 별로 없다
- 답이 분수의 형태로 나와서 약분해야 할 때/ 수학문제 풀 때 정도 제외하고는 별로 안씀
- 유클리드 호제법을 이용하는데 검색하면 쉬운 설명이 많이 나와있다.

## 최소공배수
- 가장 안쓰는 알고리즘.. 

## 소수
- 이게 상당히 중요한 챕터
- 소수 구해보기 
1. 어떤 수 n이 소수인지 아닌지 판별
2. 1~n 범위의 모든 소수
- 소수의 정의를 그대로 구현
- 컴퓨터에서 실수는 근삿값, 안쓰는게 좋다. (오차가 있기 때문에)
- 소수를 구할 때 1번을 사용해서 2번을 구하는 방법의 시간 복잡도는 N루트N으로, 상당히 긴 시간이 걸린다.
- 작은 수 부터 그 수의 배수를 모두 지운 후 남은 아이들은 소수다. 7까지만 지우면 됨
- 시간 복잡도는 엔로그로그앤인데 그냥 외워라 이해할 필요는... 엄청 빠른 편이고, 소수 구할 때는 이걸 이용하면 됨.
- 어떤 수가 소수인지 아닌지도 함께 구할 수 있다. 지워지지 않은 것(true 인지) vksquf gkaus ehlsek.
 ```c
 int prime[100];
 int pn=0;
 bool check[101];
 ```
 
 ## 골드바흐의 추축
 - 한 번 참고해보세요 설명은 생략합니다
 
 --쉬는시간
 - 루트n은 i*i=n 과 같이 나타냄 (i^2=n -> i = 루트n
 
 ## 123더하기 5
 - 마지막 수에 따라서 연속하면 안되는 수가 있기 때문에 그냥 합을 n-1이라고 하면 안된다
 
## 쉬운 계단 수
- 마지막 수 L
- n-1에 오는 수는? L-1 , L+1이 올 수 있다.
- 주로 이런 인접한다 연속한다 같은 문제들은 마지막에 오는 수를 이용해서 구한다.
- 문제를 풀 때는 0~9까지 나눈 후 마지막에 합쳐줘야한다
- 차원이 늘어난다고 해서 난이도가 올라가는 건 아니다.
## 오르막 수
- 집에서 연습해보세요! 숙제입니다.
- 위랑 비슷합니다.
## 이친수
- 123더하기 5랑 비슷하지만 아니야~
- 첫번째에 0이오면 안되니까 0, 1이오는 경우 1개 
- 일차원으로도 해결할 수 있는데, 마지막 수가 0이면 d[n-1], 마지막 수가 1이면 d[i-2]인 이친수 앞에 0,1을 붙이는 것
- 따라서 피보나치와 똑같은 점화식이 나온다. (+ d[1]=1까지 ) //연립방정식 같다...문제의 조건을 하나하나 점화식으로 만드넹
## 가장 긴 증가하는 부분 수열(LIS) *중요
- 길이가 n인 수열의 부분수열의 수 : 2^n (각 숫자가 들어갈수도, 안들어갈수도 있으니)
- 앞의 경우의 수를 참고해서 구할 수 있다. 단 최댓값까지만.
- 시간복잡도는 n^2 앞의 모든수를 비교하고 뒤의 모든수를 또 비교해야하기 때문. 문제는 1000이라서 시간 내에 가능
- j<i / a[j] < a[i] :증가 /이 두가지 조건 참고
- 중요한 문제는 변형이 많고, 이 문제 역시 그러하다...
- 이 방법은 기타 다른 알고리즘에서 많이 쓰는 방법이다.
- p.151 코드에서 0부터 시작하니까 -1이다.
## 가장 큰 증가하는 부분 수열
## 가장 긴 감소하는 부분 수열
- 앞의 수 중에서 부등호만 반대로하면 됨.
## 연속합
- 음수를 기준으로 나눠서 합을 구한다? 노. 음수를 포함해도 제일 클 수도 있다. (3 -1 3)
- 부분 연속합을 구해서 가장 크면 그 뒤에오는 수는 어차피 같으니까...
- 앞의 수랑 연속되는게 큰지, 혼자가 큰지 순서대로 체크한다. 
- d[i] 중에서 최댓값을 선택해야한다.
- 문제에 답이 음수가 될 수 있으므로 ans=0이 아니라 d[0]이라고하고 최대값을 구한다. (또는 문제의 최소값인 -1001을 넣던가)
- 왜 배열이 아니고 벡터를 쓰나요? 이유는 없어요 속도 메모리 차이없어요 코드 짤때 배열쓰면 전역변수 쓰기 귀찮아서 
#### 문제 풀이 힌트
- 먼저 벡터로 a(n)을 만든다음 모든 입력을 받아 넣는다.
- 그리고 d(n) 벡터(=배열)을 만든다.
- 입력된 수열의 길이만큼 for문을 돌리면서,
- 수열안의 숫자를 벡터에 넣고 만약 0번째이면 계속하고,
- (현재 수 + 바로 전의 수)가 현재 수보다 크면, 현재 수에 (현재 수 + 바로 전의 수)를 넣는다.
- for문을 나옴
- 정답을 d[0], 즉 정답이 될 수 있는 최솟값으로 초기화 하고
- 수열의 수 만큼 for문을 돌리면서 d[i]의 최댓값을 찾아 출력한다.
if(ans<d[i]) < 왜지?

## 브루트포스 알고리즘
- 문제에 있는 방법을 모두 해보는 것.
- 경우의 수를 다 해보는데 걸리는 시간이 시간 제한을 넘지 않아야 한다.
- 그래서 브루트 포스로 문제를 풀 때 방법의 수를 먼저 생각해보고, 그게 많지 않다면 이 방법을 사용한다.
- 재귀함수를 사용하는 방법이 가장 중요하다. 
- 이유는 재귀함수가 나머지 방법을 다 사용할 수 있기 때문.
## 일곱난쟁이
- 9명 중 7명 뽑는 것= 9명 중 2명 뽑기 9*8/2
## 사탕 게임
- 방법의 수 n^2 50이라 2500가지 정도라 많지 않아서 브루트 포스로 풀기가 가능함.
- n이 1000만 돼도 못 구한다. 
- 방법의 수 계산 후 for문으로 쭉 돌리면서 인접한 최대 수 구한다.
## 날짜 계산
- 방법의 수가 적어서 가능함 15*28*19 =7890이다.
- 만약에 제한이 달라지면 브루트포스로 풀 수 없다. 
- 중국인의 나머지정리를 쓰면 한줄로도 풀 수 있지만 중요하지 않으므로 소스 코드만 첨부한다

#### 다음시간에 오기 전에 
- 문제집 -> n과m이라는 문제를 풀고와라
- 1234, 5678 풀어보고 오세요 
- 다음 시간에 n과m을 어떻게 구현하면 좋을지 설명하면서 시작할 것이다.

## 제곱수의 합
- 123더하기랑 똑같당(n을 123의 합으로 나타내는 방법의 수)
- 경우의 수와 최솟값을 더하는 건 같다. 
- 점화식 마지막에 +1이 오는 이유 L^2이 오면 하나가 빠지니까 (개수니까)
- 시간 복잡도는? O(N*루트N) 
## 타일채우기
- 의미가 없어서 안함(스킵해~)
## 합분해
- 난이도는 가장 어렵고 가장 중요한 문제
- 앞의 문제랑 점화식 세우는 방법이 비슷하다. (혼자 한번 시도해봐)
- 시간 복잡도는 KN * N(하나의 배열 채우는 시간)
- 세개의 곱이 나왔으면 범위를 체크해봐야 한다.
- 시그마?(모든 합)
- 참고로 d[k][n]=d[k][n-1]+d[k-1][n] 으로 시그마가 아니라 간단하게 구할 수 있다.(시간 절약가능)
- 그림으로 그려보면 이해가 갈 것이당

#### 팁~
- 다이나믹은 조금 공부하면 제일 쉽다고 생각하기도 하는 유형이다
- 모든 경우의 수를 손으로 다 써보거나 하면서 풀어보는 걸 추천

## 간단한 문제(#11659)
- 쿼리문제
- 불필요한 연산을 줄이는 하나의 예시 (나중에 또 할거야 예습한거야)














