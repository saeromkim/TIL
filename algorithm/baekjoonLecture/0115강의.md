# 그래프1
- 가장 많이 사용되는 자료구조 중 하나 
## 경로
## 사이클
- a에서 a로 다시 돌아오는 경로
## 단순 경로/단순 사이클
- 같은 정점을 두 번 이상 방문하지 않는 경로/사이클
- 일반적인 경로/사이클을 말함
## 방향 있는/없는 그래프
- 방향이 없으면 양 방향
- 모든 양 방향 그래프는 a->b / b->a 따로 두개 저장해야 함
## 간선 여러개
- 중요하진 않지만..
- 여러개면 하나만 저장하면 됨. 어차피 최단이니께
## 루프
- a->a
- 이런 그래프는 거의 안나옴. 한번도 못봄
## 가중치
- 제일 중요함
- 이동하는 비용
- 없으면 1이라고 생각하면 됨
## 차수
- 정점과 연결되어 있는 간선의 개수
- 방향이 있으면 In-degree, Out-degree로 나누어 계산
# 그래프의 표현
- 정점은 개수만 알면 됨
- 각 사람이면 번호 매기면 됨 (매핑해주는 과정 필요)
- 중요한 건 간선.
- 무엇과 무엇을 연결하는 것이 중요 (간선을 저장)
- 한 정점과 연결된 간선을 ~효율~적으로 찾는 것이 가장 중요
- 1차원 배열이라면 하나씩 다 검사해야할 것이다
- 그래프에서는 시간, 공간 둘 다 중요하다.
## 인접 행렬
- 2차원 배열 사용
- A[i][j] = 1 (i -> j 간선이 있을 때), 0 (없을 때)
- 예)1행5열, 5행1열 둘다 저장
#### 성능 측정에 필요한 두가지
1. 정점이 v이면 필요한 공간은 v^2개 필요하다
2. 한 정점과 연결된 모든 정점: O(v) 
- 하나를 찾기 위해 다 찾아야 함
- 인접 행렬은 거의 사용하지 않는다. 더 빠른게 있음
## 인접 리스트 <이 것만 알면 뭐..그래프 끝
- 그래프는 무조건 인접 리스트
- 코딩하기 귀찮은데 제한이 작으면 인접행렬써..
- 링크드 리스트는 동적할당을 하기 위함인데, 길이가 변하는 배열이 있기 때문에 안써도 됨
- c++ : vector, java: array list, c : 없음
- 공감: 간선의 개수(e) 만큼 필요
- 한 정점과 연결된 모든 정점을 찾는 데 걸리는 시간 : O(차수)
- 인접 행렬은 두 정점 x,y를 연결하는 간선이 존재하는지 찾을 때 쓴다.
- a[x][y]가 1인지 0인지 근데 거의 쓸 일 없음
- 가중치가 있으면 간선과 같이 a[2] (4,3) 과 같이 저장
## 간선 리스트
- 배열 쓰고 싶을 때, vector못 쓸 때, 라이브러리 못쓰게 할 때 사용해.. 쓸 일 없겠지만
- 인접 리스트랑 똑같은 시간 복잡도를 갖는데, 만드는 데 더 오래걸림
- 배열을 이용해서 구현함. 책에 안나옴. 이름은 내가 정함
- 간선을 모두 저장한다. 1차원 배열에 모두 저장
- 앞 정점을 기준으로 정렬 후 개수를 센다
- 정렬해야해서 시간 오래 걸림(정렬 구현 귀찮음)
# 그래프의 탐색
- 한 정점 시작해서 연결된 모든 정점을 한 번씩 방문 = 그래프 탐색의 목표
- 탐색 순서 중 D(Depth)FS, B(너비)FS가 있다.
## 깊이 우선 탐색(dfs)
- 스택사용
- check[i]배열 사용, 방문하면 1
- 1에서 5,2아무데나 가도됨
- check[i]==1이면 가면 안됨~
- 5에서 더 갈 수 있는게 없기 때문에 4로 돌아간다
- 순서는 여러가지다(중요하지 않음 dfs에서)
- 재귀 함수 사용한다(코드 참고)
- v번 함수가 호출됨
- 시간 복잡도 v^2 (하나의 함수가 v번)
- 인접리스트를 사용하면 다음 정점을 방문한적이 없는지만 체크하면 됨
- 모든 정점, 간선을 다 검사하는 데 걸리는 시간 O(v+e) e가 더 크기 때문에 O(e)라고 써도 됨
- dfs를 브루트포스라고 말하는 경우가 많다
- 브루트포스는 모든 걸 다해보는 거라 for문 끝에 check[i]=false라고 다시 해준다
## 너비 우선 탐색(bfs)
- 큐 사용
- 방문 시 정점을 큐에 넣는다. 
- 큐에 넣을 때 방문했다고 check를 1로 만든다
- 시작점은 내 맘대로인데 코드에선 1이라고 하고 큐에 넣는다. 이 때 check도 1로
- 다음 정점 찾는건 dfs랑 같다.
- bfs에서는 함수 호출 대신 큐에 i(정점)을 넣는다.
- 인접리스트 사용하면 역시 더 빠름

- (72p) 인접 리스트 소스만 보면 됩니다. 밑에 두개는 참고용
- 대부분의 그래프 탐색 문제는 BFS를 이용하는 문제 
- 수준이 어려워지면 그 때 DFS사용
- 지금은 BFS를 이용하는 최단거리 문제가 가장 중요
//BFS 인접 리스트로 구현한 코드 소스
```c
    queue<int> q; //q에 할당
    memset(check,false,sizeof(check)); 메모리 할당
    check[start] = true; //맨처음 꺼는 true, 방문했으니까
    q.push(start); //큐에 방문한 정점 넣음
    while (!q.empty()) { //큐가 비어있지 않을 동안
        int node = q.front(); //큐의 가장 앞을 node가 가리키게 만듬
        q.pop(); //오래된 정점을 지운다. 큐는 맨 앞의 껄 지운다
        printf("%d ",node); //현재 노드를 출력한다 
        for (int i=0; i<a[node].size(); i++) { //노드 사이즈만큼
            int next = a[node][i]; //다음에 방문할 정점을 초기화
            if (check[next] == false) { //방문하지 않았을 때
                check[next] = true; //방문하면서 방문했다고 체크
                q.push(next); //다음 값의 정점을 큐에 넣는다
            }
```   
## 연결 요소(?!)
- 그래프 1개가 연결안되어있을 때 연결되어 있는 요소를 말한다.
- 연결그래프가 아닐 수 도 있다.
## 이분 그래프
- 상당히 중요
- 그래프를 나눌 수 있으면 이분 그래프라고 한다. (사람이 문제를 풀때 사람 수, 문제 수)
#### 이분 매칭
- 사람, 역할이 있을 때 각 사람은 어떤 역할을 하고 싶은지 고를 수 있다.
- 이 때 최대한 많은 쌍을 매칭해주는 것
- 네트워크 플로우라는 알고리즘을 쓰는데.. 참고만
## 플러드 필
- 배열 채우기. 단순.
#### 단지번호붙이기
- 연결요소 찾는 문제랑 같다
- 연결되어있는지 찾으면 되기때문에
- 그림이 그래프 형식이 아니지만 변형할 수 있다. 변형하는 능력이 중요
- 정점이 X,Y 좌표로 바꾸고 앞의 BFS랑 똑같다.
- 얘는 정의만 잘 정하면 코드는 같기 때문에 DP보다 더 긍정적..

# BFS
- 임의의 정점에서 시작해서 모든 정점을 한 번씩 방문하는 것이 목표
- 모든 가중치가 1일 때, 최단 거리를 구하는 알고리즘
#### BFS로 풀 수 있는 문제
1. 최소 비용 문제
2. 간선의 가중치가 1
3. 정점과 간선의 개수가 적어야(1초안에 계산할 수 있는 것)

- *2 / >>1 의 차이는 거의 없고, 컴파일러가 최적화해주기 때문에 신경 ㄴㄴ
- i++, ++i 둘도 이제는 차이 없다
## BSF 기초 세문제
#### 숨바꼭질
- 가중치가 1이 나옴
- 최소비용
- 다음 정점 저장 안해도 됨.
- 문제를 그래프로 변형 가능
- 다음에 대한 조건이 나와있으면 쉬운 문제다(그래프로 곧바로 옮길 수 있음)
(....)
#### 숨바꼭질4(??)
- dp에서처럼 역추적하는 방식
- 스택을 이용하는 법(..)
#### DSLR
- BFS로 풀 수 있는 이유만 설명하겠음
- 연산이 모두 1번씩
- 네 자리 숫자라서 정점 10000개, 간선 40000개(정점*연산 4가지)라 구할 수 있다.

- 정점을 나눈다 = DP에서 점화식을 세운다
#### 이모티콘
- 정점: 화면의 이모티콘의 개수, 클립보드에 있는 이모티콘의 개수 (S,C)
- 최소값이 므로 BFS로 풀 수 있다.
- 상태가 BFS로는 정점, 다이나믹에서는 점화식 
- 다이나믹으로도 풀 수 있는 문제긴 해
- 배열 두개 사용 check[], dist[](거리)
- 배열을 하나만 사용하기 위해 dist가 -1이면 방문 안한거 0이면 방문한거. 시간이 음수가 될수는 없으므로
(...코드보기...)
- 언어의 연산의 복잡도를 아는 것도 중요하다
#### 퍼즐
- 8퍼즐을 푸는 문제
- 한칸씩 이동하는 것이 1이고 각 칸을 정점이라고 생각하면 되므로 bfs로 풀 수 있는 문제다
- 총 퍼즐 상태 개수는 9!=362,880
- 만약 16퍼즐이면 배열이 너무 커져서 못 푸는 문제가 된다. (bfs를 양쪽에서 시작하면 풀 수 있는데 어려움)

#### 잡담
- 이 문제가 왜 BFS로 풀 수 있는가?
- 복습해오기
- 기초, n과m은 브루트포스를 재귀로 풀때 중요
- 순열,비트마스크,재귀 다룰 예정
- 기타, 문제 : 자습용
- 슬라이드는 많이 올릴 테니 자습용으로 많이 참고하시길..
# 브루트포스
#### 리모컨
- 숫자를 누르면 앞에 께 다 초기화되므로 먼저 숫자를 눌러야 한다.
- +, - 번갈아 누르면 의미가 없어지므로, 둘 중 하나만 누른다.
- +가 몇개가 필요하는지는 7-1=6번 처럼 계산을 통해 구하낟. 
- 채널을 모두 만들고 고장난게 있는지 검사
- 답은 50만을 넘지 않는다.
- 따라서 숫자버튼을 눌러서 이동하는 채널c는 0<=c<=500,000 이면 된다. 대략. 작은차이라 괜찮다
- 이동할 채널 C
- 난이도는 중하 , 해야할게 많다
#### 테트로미노
- 어떤 블록을 넣을 건지, 어디에 놓을 건지 결정해야 함
- 각 블록의 경우의 개수는 다 다르다. 총 19개(회전, 대칭했을때)
- N*M 크기의 종이 위
- 시간복잡도 O(NM) , 전체 경우의 수 19*500*500 =375,000 이라 얼마 안된다.
- 즉 다 해봐도 된다는 것
- 각각의 코드를 놓는 코드를 모두 만들면 됨
- 여러 방법이 있다. 19가지 모두 다 하는 것, 아니면 배열로 다 놓는 법
- 대칭, 회전 시키는 코드를 만들어서 모두 해보는 방법이 소스3인데 시간이 오래 걸린다. (우리 기준으로는 좋지않은 방법)
- DFS로 풀 수 있다. 나중에 풀어볼 거임 




         








