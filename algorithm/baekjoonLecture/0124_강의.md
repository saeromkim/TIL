# 문자열 알고리즘
## 문자열 매칭 알고리즘
- 모든 경우를 다 해보는 경우는 너무 오래걸림 (aaaa, aaaaaaaa)인 경우
## kmp
- prefix==suffix 가 될 수 있는 문자열의 길이 (여기서 -1을 하면 인덱스가됨)
- 문자열의 길이비교는 정수와 다르게 문자열의 길이만큼 걸림
- 7번째  pi[]를 조심해야한다. 0이 아니라ab가 같아서 2임
- (코드)
- 7번째 재귀 돌아가는거설명해주는데 머리아픔..다시보기ㅠ
- 시간복잡도 o(s+p)
- 어려웡 문제푸는게 목적이라면 패턴 구하는 건 이해하지 않아도되미
- 하지만 pi값을 구하는 건 알아둬
#### 광고
#### cubeditor
- kmp랑 pi에서 가장 큰게 정답
- kmp를 모든 문자열에 대해서 해야하므로 앞에서 하나씩 지우면서..
- 왜냐하면 부분문자열을 모두 구해야 하므로.
- 시간복잡도는 o(s^2) , kmp를 각각 모두하니까. 
#### 순환순열
- 앞에 나온 두 문제보다는 중요도가 떨어짐
## Trie
- kmp; 문자열 s에서 패턴 p를 찾는 것(ctrl+F)
- Trie; 문자열 n개 중 문자열s를 찾음(최백준 찾기)
- kmp+Trie; 문자열 n개 중에서 패턴 p를 찾는 것(*백준 찾기)

- '정수'가 아닌 '문자열'에서 어떤 값이 존재하는지 찾을 때: 길이*O(lonN)
- trie는 prefix의 트리다 
- 찾고자 하는 문자열을 루트에서부터 찾으면 된다
- 추가 삭제 모두 문자열의 길이 만큼 걸림
- abc를 넣었는데 ab를 찾고자 할때 있어도 없다고 해야하는데,
- 자식이 없는 리프노드까지의 경우만 있다고 해야함
- 인덱스는 26개(알파벳 수)만큼있어야하고 동적할당 귀찮으니까. 몇개 없잖아
- 루트는 "" 항상존재 빈문자열
- (코드, 추가코드 zzz)
- 삭제는 사용빈도 적음
- prefix tree라고 한다. (자동완성)
- 노드만들면 26개만들고 다 -1넣는 방식인데, 공간 비효율, 근데 시간은 효율
- 새로운게 추가되면 자식들을 링크드리스트로 갖는 형태면 공간은 효율적. 근데 시간은 비효율
#### 두 수 xor
- 수에 대해서 쓸 때, 수를 이진수로 바꿔서 trie사용 하면 됨
- 뒤의 문제들도 모두 비슷한 방법을 푼다. 
- 수에 대한 xor처럼으로 trie가 가장 많이 쓰인다.
## aho-corasick
- kmp, trie좀더 살펴보고 이 것 보자
# 잠깐 다이나믹 2
#### 이동하기
- 이동할 수 있는 방법이 3가지 방향이라서 다이나믹으로 풀 수 있다.
- 네방향이었다면 완전 쉬운 문제, 모든칸을 방문한 후 합을 구하는 문제가 된다.
- 이동하면 위, 왼쪽으로 못감 그 부분은 없다고 해도 됨. 문제가 점점 작아짐
1. 방법 1
- i,j가 왔다 어디에서 왔을까?
- max3으로 왼쪽 대각선위, 위에서 온 경우를 모두 구해서 최댓값구하면됨 . max 두번 중첩이 젤 좋은 방법
2. 방법 2
- i,j가 왔으면 다음은 어떻게?
- n개가 있는데 하나를 빼면 어떻게? 마지막 수가 무엇이면?이런식으로 풀었는데.. 이게 방법1
- 주로 이런 문제,, 직관적
- 설명할때 주로 방법1로 설명하는데 이유는 코드가 간단해서. 원하는 방법으로 푸세요
3. 방법 3
- 대각선은 처리하지 않아도 된다. 
(쉬는시간)
- 코드 보기 bottom up 별로 안김
- 같은 문제를 여러방법
- 같은 문제를 같은 방법
- 모두 다른 문제들

- 조건을 더 추가하기 머리아프니까 배열을 +1해서 -1,-1부터 시작하다고 생각해도 됨
#### 팰린드롬
1. 어떤 문자열이 팰린드롬인지 아닌지 찾는 문제
- 뒤집은 거랑 같은지 비교
- 앞에서부터+1 뒤에서부터+1 해서 비교
- 둘다 O(n)

- 이 문제는 부분 수열이 팰린드롬인지 확인하는 문제
- 위 방법을 그냥 쓰면 o(nm)으로 시간 초과
- level은 양끝 문자가 같고, 중간이 팰린드롬이라서
- (코드) 간단 이중for문 x
- 길이를 정하고 시작위치i, 길이를 +1해주면서 바텀업 
- 이 때, 끝나는 위치에 -1을해야하는데, 이는 배열이 0부터 시작하기 때문
#### 1,2,3 더하기 4 (동전교환 알고리즘)
- 순서가 달라도 같은 것으로 취급
- 오름차순인 것만 구한다.
- 1차원 방법이 가장 좋은 방법
- 경우의 수, 최솟값의 차이는 합을 할 건지,min을 구할 건지의 차이일뿐
#### 동전 1
- 순서가 달라도 구성이 같으면 같다고 해야하기 때문에, 앞의 문제랑 같은 경우다
- 실제로는 다이나믹 안해도 됨
- 큰 수 부터 하면 됨. 이유는 배수라... 배수가 아니면(1,4,5원) 다이나믹 해야함
#### 평범한 배낭
- 유명하다. 냅색문제 knapsack
- 넣는다, 넣지 않는다 이므로 브루트포스로 풀 수 있다. O(2^n)
- 다이나믹 O(nm) 으로도 풀 수 있는데 가방의 최대 무게를 이용
- 2차원임. 
- 브루트포스와 비교해서 시간이 빠른 걸로 푼다.
- 대부분은 브루트로 푼당
- 그리디 알고리즘: 단위무게당 가치를 계산해서 넣는 방법(비추천, 답못구함)

- 다음시간은 다이나믹 문제(중요한 시간에 남는시간에 매일 풀거야)
- 그리고 그리디랑 이분탐색 위주로 할거양



