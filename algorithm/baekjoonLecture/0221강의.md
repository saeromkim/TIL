# 조합 게임
- 재밌는거~~~
#### 돌게임
- 베라31 게임
- 마지막 돌을 가져가는 사람이 게임을 이긴다
- 돌 1,2,3일때 a가 무조건 이김.
- 돌 0,4일때 b가 이김
- 마지막 돌을 가져가는 사람이 이긴다. d[[0]= false 해주면됨
- 마지막 돌을 가져가는 사람이 진다. 면 d[0] =true하면 됨. 
- 다이나믹으로 품
- 돌게임 1234시리즈가 많아. 
- 모든 돌게임 문제는 주기를 가진다.
- 돌게임5 에서 범위가 너무 크면 배열에 다 저장할 수 없으므로 주기 반복을 이용하면 됨.
- 돌게임6도 주기가 7개씩 반복이므로..
- 주기는 직접 표를 그려서 찾는게 더 쉽다.
- 돌게임8은 주기를 찾는 코드를 따로 작성해야 함
#### 박스 나누기 게임
- 2차원으로 풀기. 
- 조합게임은 다이나믹으로 풀 수 있다.
- 이거 좀 이해안감. ㅠ다시 봐야할 듯
#### 님 게임
- 기초 ,알면 좋음
- 박스 나누기에서 박스가 3개 있다는 것
- 마지막 돌을 제거한 사람이 게임을 이기게 된다.
- 박스 나누기를 3개 동시에 진행하는 것
(멍)
- (0,0,k)는 무조건 윈. 다가져가면 됨.
- (0,1,1)는 짐
- 돌의 갯수를 xor한 결과가 0이면 짐
- 제일 중요한 게임. 왜냐면 다이나믹 안해도됨
#### 님블
- 모든 동전이 0에 있으면 게임이 끝나게 되며,마지막 동전을 0으로 옮긴 사람이 게임을 이긴다
- 님게임이랑 같은 거임. 똑같이 xor한 값 판별.
- 동전을 이동하는 거랑 돌을 이동하는 거랑 같기 때문
- 여기까지가 조합게임의 기초
- 이제부터 일반화된 모든게임을 풀 수 있는 방법
# grundy number
- 모든 게임에 대해 다 구현할 수 있음
- 가리키는 수를 제외한 가장 작은 수
- 각 상황들의 xor이 0이면 지는 위치, 1이면 이기는 위치
- 님게임처럼 하나를 선택하는 경우가 게임이 여러개로 구성된 경우
- 돌덩이 3개일때, 3개의 게임이 합쳐져 있는 것. (뭐..경우의 개수 개념인듯?)
#### 님게임2
- 그런디 넘버는 자기 자신 g(i) = i
- 그런디 넘버만 구하며 됨
- 요 내용만 알면 조타
#### 님게임 홀짝
- 님게임이랑 똑같다. 돌더미 n개. 돌더미 선택, 돌가져온다
- 돌더미 돌이 0또는2개 남으면 게임이 끝남
- 먼저, 0,2개일때 그런디 넘버는 0
(멍)
- 홀짝단위로 1234567이 규칙적
- 일반항이 나온다
#### 님게임 나누기
- 멍
- 뒤에 있는 문제들은 다 그런디 넘버를 구하는 것임
- 더 이상 할 수 없는 상황이면 게임을 진다. 인 경우에만 그런디넘버로 구할 수 있다.
- 기초는 다이나믹인데.....,,..,.,
# 다이나믹 프로그래밍3.ppt
## 상태 다이나믹
#### 타일 채우기
- 마지막 칸에 뭐가 올 수 있는지?
- 3n크기의 타일 채우기
- 점화식 조건 많음
- 점화식 세울 때 그림 하나하나 직접 그려보고 세우기
- 이렇게 상태가 여러가지 있을 때 상태 다이나믹이라고 하는 듯
- 이 정도는 뭐~ 8줄 타이핑은 뭐 큰 난이도가 아님
- 절대로 나올 수 없는게 2번, 5번.
- 각각에 대해 앞에 올 수있는게 뭔지 그려보고 풀기
#### 타일 채우기 2
- 제한이 매우 크다
- 8*8행렬을 만든 다음에 구할 수 있다.
- 피보나치수가 중요한 이유는 주기를 찾는 것, 행렬을 이용하는 것
- 두 개씩 쌍을 지어서 저장을 하다가 똑같은 쌍이 나오면 아 주기구낭
- (주기찾는 코드)
#### 외판원 순회
- 브루트포스 순열이용해서 풀었었는데,
- n이 16이면 다이나믹으로도 풀 수 있다. 
- 시작점을 1로 고정시키고.. 1234 1324 일때.
- (멍)
- 대부분 순열 문제는 대부분 다이나믹으로 푼다. 왜냐면 대부분 하나만 의미있는 경우가 없어서..
- 앞에서 순열을 한 이유가 이 내용을 위해서.
- 시작점은 고정시킬꺼니까 별로 필요가 없고..
- 어떤 도시를 방문했는지랑, 마지막 도시만 중요
- (빈페이지)
- 2가지 방법.
- 공통) 0에서 시작 l까지
- d[s][l] = 방문한 도시의 집합이 s. 마지막 방문. l
- 조건: l이 s에 속해있을 때만 가능(당연)
- 1번째 방법)
- l이전 방문 도시가 p
- 작은 문제 o~p, 조건
- (1<<l)이 l을 방문했다는 것
- d[s& ~ (1<<l)][p]와의 최솟값을 구하면됨 
//여기서 s& ~ (1<<l) 라는 것은 s에서 n번째를 빼는 것임. 
//++)= 피자 a 의 n 번째 토핑이 없으면 첨가하고, 있으면 제거합니다.
//`a ^= (1 << n)` 즉 n번째를 토글
//( a & ~b)     // 차집합 a - b
//if (i&(1<<j)) j번째가 1인지 확인
//` a  |= (1 << n)` 피자 a에 n번 토핑 추가하기
- 2번쨰 방법)
- 확장하는 법. 다음에 갈 도시가 p라고 가정
- 상태 s에다가 1<<p한 것. p까지 가야하니까
- 조건. p는 s에 없음
- (비트마스크? bool로 체크하는 배열을 비트마스크로 나타낼 수 있다. 빨라서 사용)
- 이게 비트마스크를 이용한 상태 다이나믹
- 실제론 다른 것도 비트마스크라고 생각할 수 있다.
- O(2^n * n^2)
#### 쉬운 계단 수
- 외판원 순회 처럼 이전상태 또는 다음상태 두가지로 나눠서 풀 수 있는데
- 0~9가 모두 등장하는 계단 수가 몇개 있는지? ->비트마스크 쓰면 좋음.
- d[n][l][s] 길이n 마지막l 등장s 
- (비트마스크 별거아니네.  겁먹을 필요없음)
- 등장때문에 비트마스크가 포함되는거지 다른 유도 방식은 같음
- [f]가 추가 되고, 처음1 아니면 0 인것도 고려할 수 있음 근데 복잡하니까 안함
#### 계단 수
(쉬는시간)
#### 컨닝
- 비트마스크
- 모든 행이 사람이 앉는다/앉지 않는다로 나뉨
- 하나의 행에 대해 올 수 있는 모든 상태를 구할 수 있다. 
(소스코드보기)
- row-1 pstate, row state이렇게 두가지 경우의 수를 체크해서 구한다.
- 소스코드보니까 이해된다!
- (state < (1<<m) ?)
#### 격자판 채우기
- (멍)
- 마지막 칸에서 0이번 올바르게 채운 것
- 행단위로 다 채워보는 것, 하나씩 상태를 보며 채워보는거
- 격자판 채우기가 가장 기초
(코드)
- 뒤의 두세개 문제도 다 이방식으로 푼다. 그래서 이게 가장 중요한 문제
- 수업시간 중 가장 어려운 다이나믹 문제가 격자판 채우기. 
#### 두부장수 장홍준
- 격자판이랑 똑같은 문제
#### 4블럭
(멍)
- 격자판 나오는건 그림을 꼭 그려보고 그걸 그대로 쓰는 방향으로
#### 체스판
- 4블럭이랑 문제가 똑같은데 4가지에 대해 상태가 어떻게 변하는지 알 수있다.
- 열에 대해 문제를 풀면 됨.
#### 체스로 도미노를 타자
- 격자판이랑 비슷. k개란 조건이 추가됨


- 격자판 채우기만 이해하면 왠만한 상태 dp문제는 풀 수있다.
- 다음 주 세그먼트 문제 풀거고 문제 미리 읽어오세요.
- 다음 주가 마지막 수업....
- 시뮬레이션 추가할 거고. 한번보세요. 기타도.
- 목요일 마지막 수업인데 뭘 할지?
- 비트마스크랑 구간최솟값(bit,세그먼트트리)은 코테랑 상관없음
- 목요일에는 그럼 뭘 하죠?네? 그냥 문제 풀게요. 아무거나 섞어서리 이 문제는 무슨 방법으로 풀까요?
- 다음시간에 aho korasic 
- 정렬로만 푸는 문제도 풀어볼거다. 다음시간에
- (복습 열심히 해야겠다)
