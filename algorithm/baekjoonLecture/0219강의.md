# RMQ.ppt
- 지금부터 다음주까지는 코딩테스트 이상의 난이도 
- Range Minimum Queue
### 구간의 최소값 구하기
- A[i]부터 A[j]까지 중에 최소값
- 시간복잡도 O(n)
- 여러가지 방법을 볼 건데, 결론은 하나임

#### 방법1) 루트n으로 나누기
- O(쿼리 수행 전에 준비하는 시간(전처리) + (쿼리의 개수 * 하나의 쿼리 수행시간))
- 루트 n으로 나누기 = 그룹의 개수와 그룹의 크기가 같다는 점을 이용한다.
- 루트를 그룹번호로 나눈 후 그룹의 최솟값을 구하낟. 
- 나머지가 0이면 첫번째 수.. 거기서부터 계속 비교하는 방식으로 해서 구할 수 있다.
- 오차가 발생해도 크지 않기 때문에 괜찮다.
- i와 j가 같은 그룹인 경우와 그렇지 않은 경우를 나눈다.
- 같은 그룹이면 다해보기 방법으로 i~j for문
- 다른 그룹이면? 
- i와 j 사이에 들어있는 그룹은 그룹채로 최솟값을 구한다.
- (11명..?)
- 이건 lca문제에도 적용 가능
- 이 방법은 O(루트n)인데, 방법은 느려서 잘 안씀
 #### 방법2) 다이나믹 프로그래밍
 - 2^j 번째 구하는 거 lca할 때 한거랑 똑같음
 - d[i][j] = a[i]부터 2^j개의 최솟값
 - 2^j를 2^j-1+ 2^j-1로 나눈다
 - 전체 2의 제곱 수를 쪼개면서 찾는다. 
 - 쿼리 하는데 걸리는 시간 O(logN)
 - logN이 훨씬 빨라서 더 좋은 방법
 - lca문제를 rmq로도 풀수있고 거의 같은 문제라 보면된다.
 - 이 방법도 잘 안씀 
 #### 방법3) 세그먼트 트리
 - 이걸 할 줄알면 고수임
 - 구간 트리라고 보면 됨
 - 전체 구간을 절반으로 쪼갠 후 각각의 최솟값을 구하는 것.
 - 포스트 오더 방식으로 노드를 채울 것
 - 저장은 배열에 
 - 노드는 node가 저장된곳, Start, end 세 값을 가지고 있다.
 - 항상 구간을 절반으로 나누기 때문에 부모는 항상 자식을 두개 가질 수 있다.
 - 리프노드의 경우는 그 값을 넣어조야댐
 - init이라는 선처리 하는데 걸리는시간이 있어. 
 - (약간 이분탐색 느낌남..)
 - 트리가 n이면 logn만큼 걸린당
 - 실제로 젤 중요한 방법. 
 - 합, 최댓값 구간 안이면 다 구할 수 있다
 - min을 sum이나 m1+m2로 바꾸면 됨
 - 변경하는 것도 쿼리랑 똑같이 구현하면 된다. 
 - 만약 3을 변경한다 그러면 리프노드가 3인걸 찾으면 됨 
 - 트리의 한쪽으로만 탐색이 진행되니까 logN만에 구할 수 있담
 - 이 두가지만 알면(최솟값 코드, 변경 코드)세크먼트 트리는 다 아는거라고 보면 됨
 - 인덱스 트리라고도함
 - 바이너리 인덱스 트리는 다른거임
 - 여기까지 세그먼트 트리가 오늘 할 내용과 다음시간에 할 내용의 주제였다...
 (쉬는시간)
## sliding window
##### 최소값 찾기
- 덱 쓰면 됨
- 1-4 -> 2-5 면 1이 빠지고 5가 추가됨을 이용
- 덱을 이렇게도 쓰는구나..그런 거임 그냥 한 번 보고 넘어가기로.

## 빈화면
- lac <=> rmq
- dfs 탐색 해서 수열만들고 최솟값을 구하면 rmp를 lca로 구하는 법
- 그림보면 쉽고 간단함
- 카르테시안 트리 : lca를 rmq로 만드는 것. 잘안씀 어렵

# 세그먼트 트리와 펜윅 트리
- 세그먼트에서 변경을 어떻게 할것이냐
- 비재귀 방식으로도 할 수 있다
- (코드 보면 알겠지만 ㅈㄴ복잡.)
- 재귀보다 빠르다. 나는 비재귀로 구현함. 재귀안씀
- 비재귀로 구현한 세그먼트 트리를 인덱스 트리라고 한다.
## lazy propagation
- 필요할 때 구간을 업데이트 하는 것
- 화면 로딩방식이랑 비슷하다
## fenwick tree(바이너리 인덱스 트리. BIT)
- 바이너리 인덱스드 트리라고도 함
- 합인 경우. 루트에서 왼쪽값을 알면 전체-왼쪽하면 오른쪽도 알 수 있으므로 오른쪽을 알 필요가 없다.
- 저장공간이 줄어든다. nlogn -> n으로
- 팬윅트리는 세그먼트에서 오른쪽노드를 지워버린 형태다.
- 코드가 개짧앙 그래서 좋다
(쉬는시간)
- i의 마지막 비트 :i를 2진수로 나타냈을 때, 가장 마지막 1이 나타내는 값
- 3 = 11(2)
- num & -num을 하면 바로 구할 수 있당 O(1)임
- 노드가 담당하는 구간이 어디서부터 어디까지인지 알아볼때 쓴다.
- 합을 구할 땐 마지막 비트를 빼면서 구한다. (이 부분 약간 이해 안가네~)
- 소스가 매우 짧다. 
- 세그먼트보다 훨씬 빠르다.
- 다른거말고 합은 펜윅트리가 가장 빠르다.
## 2차원 펜윅트리
- 2차원 배열은 1차원배열의 1차원배열
- 그림을 보면 복잡해보이는데, 2차원 배열 sum구하는 거랑 똑같당
- 이론상으로는 어렵지만 코드는 쉽고 이해가능.

## 2차원 누적합
- 전체 에서 왼쪽, 위쪽 빼주고 왼쪽 위 더하면 됨. 
- megasolution?

- 다음주 화요일은 세그먼트, bit어떻게 활용할지
- 다음주 화요일까지 슬라이드 문제 읽어오기

# 다이나믹 3
#### 내리막길
- 위상정렬로도 풀수있다. 내려가면 다시 못올라오니까
- 어떤 점까지 오는 길을 미리 다 계산해놔야 현재 점까지 오는 방법을 구할 수 있다.
- D[i][j] = (i,j)에서 시작해서 (N,M)로 가는 내리막 길의 개수
- 사이클이 없기 때문에 둘다 풀 수 있음
- 다이나믹이면 재귀방법으로.
- 각 칸에서 다음칸을 갈 수 있는지니까
#### 욕심쟁이 판다
- lis인데 2차원배열로 푸는 문제
- 내리막길이랑 유사. 똑같은 방식으로 해결
#### 1,2,3 더하기 7
- 우웩 ㅠ
- 사용한 수의 개수는 m개 이어야 한다.
- 사용한 수의 개수도 중요하니까 2차원으로 풀어야 한다
- 조건이 추가될때마다 점화식에 넣어보면 된다.
- (차근차근 1부터 풀어보자)
#### 1,2,3 더하기 9
- 사용한 수의 개수는 m개 이하. 이어야 한다
- 다이나믹 점화식은 똑같다.
- 답이 d[n][0]~d[n][m]까지 합을 모두 구하면 된다.
- d[0][j] =1이라고 하면 구할 수 있다. 정답.d[n][m]으로 
- 초깃값을 모두 1이라고하면 이하라고 한 값을 모두 더한 값을 구할 수 있다.
- 그림을 그려서 설명해주는데 겹치는 부분 뭔말이지. 
- 이 슬라이드는 이 문제들만 할거야.
